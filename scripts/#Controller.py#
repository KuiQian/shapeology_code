#!/usr/bin/env python3
import psutil
import socket
from os import getpid,mkdir,system
from subprocess import Popen,PIPE
from os.path import isfile
from glob import glob
from time import sleep,time
from os.path import isfile
from sys import argv
import re
import argparse
import numpy as np


def process_tiles(tile_pattern):
    i=0
    print('tile_pattern=',tile_pattern)
    for infile in glob(tile_pattern):
        
        stem=infile[:-4]
        #print ('infile=%s, stem=%s'%(infile,stem))
        lockfile=stem+'.lock'
        if not isfile(lockfile):
            i+=1
            print('got lock',lockfile,i)
            run('python3 {0}/run_job.py {0} {1}'.format(scripts_dir,stem))
            sleep(0.1)
        else:
            #print('\r %s exists'%lockfile,end='')
            continue

        # Wait if load is too high
        load=np.mean(psutil.cpu_percent(percpu=True))
        print(' %5d                            load: %6.2f'%(i,load))
        j=0
        while load>85:
            print(' %5d    Sleep:%3d               load: %6.2f'%(i,j,load))
            j+=1
            sleep(2)
            load=np.mean(psutil.cpu_percent(percpu=True))

        print('\nload low enough',load)
    return i

if __name__=="__main__":
    
    parser = argparse.ArgumentParser()
    parser.add_argument("scripts_dir", type=str,
                        help="path to the directory with the scripts")
    parser.add_argument("init_script",type=str,
                        help='the name of the script that is to run at initialization')
    parser.add_argument("main_script",type=str,
                        help='the name of the script that is to run on each file')
    parser.add_argument("s3location", type=str,
                        help="path to the s3 directory with the lossless images")
    parser.add_argument("pattern",type=str,default=r'.*',
                        help="pattern for filtering files from S3 directory")
    parser.add_argument("local_data",type=str,
                        help="path to the local data directory")
    # pattern=r'(.*)\.([^\.]*)$'
    args = parser.parse_args()

    scripts_dir=args.scripts_dir
    script=args.script
    s3_directory=args.s3location
    pattern=args.pattern
    local_data=args.local_data
    
    time_log=[]

    clock('starting Controller with s3_directory=%s, local_data=%s'%(s3_directory,local_data))

    # pre-processing
    try:
        #preparations: make dirs data and data/tiles
        run('sudo chmod 0777 /dev/shm/')
        mkdir(local_data)
        mkdir(local_data+'/tiles')
        clock('created data directory')
    except:
        pass


    while True:
        #find an unprocessed file on S3
        stem=find_and_lock(s3_directory,pattern=r'(.*)\.([^\.]*)$')
        clock('found and locked %s'%stem)

        if stem==None:
            print('all files processed')
            break

        
        #main_script
        run('rm -rf %s/*'%(local_data))
        run('mkdir %s/tiles'%local_data)
        clock('cleaning local directory')


        #Bring in a file and break it into tiles
        run('aws s3 cp %s/%s.jp2 %s/%s.jp2'%(s3_directory,stem,local_data,stem))
        clock('copied from s3: %s'%stem)
        run('kdu_expand -i %s/%s.jp2 -o %s/%s.tif'%(local_data,stem,local_data,stem))
        clock('translated into tif')
        run('convert %s/%s.tif -crop 1000x1000  +repage  +adjoin  %s'%
            (local_data,stem,local_data)+'/tiles/tiles_%02d.tif')
        clock('broke into tiles')

        # perform analysis
        i=process_tiles('%s/tiles/tiles_*.tif'%local_data)
        clock('1 - processed %6d tiles'%i)
        i=process_tiles('%s/tiles/tiles_*.tif'%local_data)
        clock('2 - processed %6d tiles'%i)

        #copy results to s3
        run("tar czf {0}/{1}_patches.tgz {0}/tiles/*.pkl {0}/tiles/*.log {0}/tiles/*.lock".format(local_data,stem))
        clock('created tar file {0}/{1}_patches.tgz'.format(local_data,stem))

        run('aws s3 cp {0}/{1}_patches.tgz {2}/'.format(local_data,stem,s3_directory))
        clock('copy tar file to S3')

    printClock()
